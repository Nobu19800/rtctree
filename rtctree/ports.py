# -*- Python -*-
# -*- coding: utf-8 -*-

'''rtctree

Copyright (C) 2009-2010
    Geoffrey Biggs
    RT-Synthesis Research Group
    Intelligent Systems Research Institute,
    National Institute of Advanced Industrial Science and Technology (AIST),
    Japan
    All rights reserved.
Licensed under the Eclipse Public License -v 1.0 (EPL)
http://www.opensource.org/licenses/eclipse-1.0.txt

File: ports.py

Objects representing ports and connections.

Do not create port objects directly. Call the parse_port function, which will
create the correct type of port object automatically.

'''

__version__ = '$Revision: $'
# $Source$


from rtctree.exceptions import *
from rtctree.utils import build_attr_string, dict_to_nvlist, nvlist_to_dict
import RTC


##############################################################################
## API functions

def parse_port(port_obj, owner):
    '''Create a port object of the correct type.

    The correct port object type is chosen based on the port.port_type
    property of port_obj.

    @param port_obj The CORBA PortService object to wrap.
    @param owner The owner of this port. Should be a Component object or None.
    @return The created port object.

    '''
    profile = port_obj.get_port_profile()
    props = nvlist_to_dict(profile.properties)
    if props['port.port_type'] == 'DataInPort':
        return DataInPort(port_obj, owner)
    elif props['port.port_type'] == 'DataOutPort':
        return DataOutPort(port_obj, owner)
    elif props['port.port_type'] == 'CorbaPort':
        return CorbaPort(port_obj, owner)
    else:
        return Port(port_obj, owner)


##############################################################################
## Base port object

class Port(object):
    '''Base class representing a port of a component.

    Do not create Port objects directly. Call parse_port().

    '''
    def __init__(self, port_obj, owner=None):
        '''Base port constructor.

        @param port_obj The CORBA PortService object to wrap.
        @param owner The owner of this port. Should be a Component object or
                     None.

        '''
        self._obj = port_obj
        self._connections = None
        self._owner = owner
        self._parse()

    def connect(self, dest, name, id, props):
        '''Connect this port to another port.

        After the connection has been made, a delayed reparse of the
        connections for this and the destination port will be triggered.

        @param dest The destination Port object.
        @param name The name of the connection. If None, a suitable default
                    will be created based on the names of the two ports.
        @param id The ID of this connection. If None, one will be generated by
               the RTC implementation.
        @param props Properties of the connection. Required values depend on
                     the type of the two ports being connected.
        @raises IncompatibleDataPortConnectionPropsError, FailedToConnectError

        '''
        if self.porttype == 'DataInPort' or self.porttype == 'DataOutPort':
            for prop in props:
                if prop not in self.properties or \
                        (props[prop] not in self.properties[prop] and \
                         'Any' not in self.properties[prop]) or \
                        prop not in dest.properties or \
                        (props[prop] not in dest.properties[prop] and \
                         'Any' not in dest.properties[prop]):
                    # Cannot make the connection with the given properties
                    raise IncompatibleDataPortConnectionPropsError
        if not name:
            name = self.name + '_' + dest.name
        ports = [self.object, dest.object]
        props = dict_to_nvlist(props)
        profile = RTC.ConnectorProfile(name, id, [self._obj, dest._obj],
                                       props)
        return_code, profile = self._obj.connect(profile)
        if return_code != RTC.RTC_OK:
            raise FailedToConnectError(return_code)
        self._reparse_connections()
        dest._reparse_connections()

    def disconnect_all(self):
        '''Disconnect all connections to this port.'''
        for conn in self.connections:
            self.object.disconnect(conn.id)
        self._reparse_connections()

    def get_connection_by_dest(self, dest):
        '''Search for a connection between this and another port.'''
        for conn in self.connections:
            if conn.has_port(self) and conn.has_port(dest):
                return conn
        return None

    def get_connection_by_name(self, name):
        '''Search for a connection to or from this port by name.'''
        for conn in self.connections:
            if conn.name == name:
                return conn
        return None

    @property
    def connections(self):
        '''A list of connections to or from this port.

        This list will be created at the first reference to this property.
        This means that the first reference may be delayed by CORBA calls,
        but others will return quickly (unless a delayed reparse has been
        triggered).

        '''
        if not self._connections:
            self._connections = [Connection(cp, self) \
                                 for cp in self._obj.get_connector_profiles()]
        return self._connections

    @property
    def is_connected(self):
        '''Check if this port is connected to any other ports.'''
        if self.connections:
            return True
        return False

    @property
    def name(self):
        '''The name of this port.'''
        return self._name

    @property
    def object(self):
        '''The PortService object that represents the port.'''
        return self._obj

    @property
    def owner(self):
        '''This port's owner (usually a Component object).'''
        return self._owner

    @property
    def porttype(self):
        '''The type of port this is.

        Valid values are any class that @ref parse_port can create.

        '''
        return self.__class__.__name__

    def _parse(self):
        # Parse the PortService object to build a port profile.
        profile = self._obj.get_port_profile()
        self._name = profile.name
        if self.owner:
            prefix = self.owner.instance_name + '.'
            if self._name.startswith(prefix):
                self._name = self._name[len(prefix):]

    def _reparse_connections(self):
        # Call to force a delayed refresh of the connections information.
        self._connections = None


##############################################################################
## Data port objects

class DataPort(Port):
    '''Specialisation of the Port class for data ports.

    Do not create DataPort objects directly. Call parse_port().

    '''
    def __init__(self, port_obj, owner=None):
        '''DataPort constructor.

        @param port_obj The CORBA PortService object to wrap.
        @param owner The owner of this port. Should be a Component object or
                     None.

        '''
        super(DataPort, self).__init__(port_obj, owner)

    def connect(self, dest, name=None, id='', props={}):
        '''Connect this port to another DataPort.

        After the connection has been made, a delayed reparse of the
        connections for this and the destination port will be triggered.

        @param dest The destination Port object.
        @param name The name of the connection. If None, a suitable default
                    will be created based on the names of the two ports.
        @param id The ID of this connection. If None, one will be generated by
               the RTC implementation.
        @param props Properties of the connection. Suitable defaults will be
                     set for required values if they are not already present.
        @raises WrongPortTypeError

        '''
        # Data ports can only connect to opposite data ports
        new_props = props.copy()
        if not (self.porttype == 'DataInPort' and \
                dest.porttype == 'DataOutPort') and not \
               (self.porttype == 'DataOutPort' and \
                dest.porttype == 'DataInPort'):
            raise WrongPortTypeError
        if 'dataport.dataflow_type' not in new_props:
            new_props['dataport.dataflow_type'] = 'push'
        if 'dataport.interface_type' not in new_props:
            new_props['dataport.interface_type'] = 'corba_cdr'
        if 'dataport.subscription_type' not in new_props:
            new_props['dataport.subscription_type'] = 'flush'
        if 'dataport.data_type' not in new_props:
            new_props['dataport.data_type'] = \
                    self.properties['dataport.data_type']
        super(DataPort, self).connect(dest, name, id, new_props)

    @property
    def data_type(self):
        '''The port's data type constructor.'''
        return self._data_type

    @property
    def properties(self):
        '''Properties of the port.'''
        return self._properties

    def _parse(self):
        # Parse the PortService object to build a port profile.
        Port._parse(self)
        profile = self._obj.get_port_profile()
        self._properties = nvlist_to_dict(profile.properties)
        # TODO: look up the data type object and fill this in
        self._data_type = None


class DataInPort(DataPort):
    '''Specialisation of the DataPort class for input ports.

    Do not create DataInPort objects directly. Call parse_port().

    '''
    pass


class DataOutPort(DataPort):
    '''Specialisation of the DataPort class for output ports.

    Do not create DataOutPort objects directly. Call parse_port().

    '''
    pass


##############################################################################
## CORBA port objects

class CorbaPort(Port):
    '''Specialisation of the Port class for service ports.

    Do not create CorbaPort objects directly. Call parse_port().

    '''
    def __init__(self, port_obj, owner=None):
        '''CorbaPort constructor.

        @param port_obj The CORBA PortService object to wrap.
        @param owner The owner of this port. Should be a Component object or
                     None.

        '''
        super(CorbaPort, self).__init__(port_obj, owner)
        self._interfaces = None

    def connect(self, dest, name=None, id='', props={}):
        '''Connect this port to another CorbaPort.

        After the connection has been made, a delayed reparse of the
        connections for this and the destination port will be triggered.

        @param dest The destination Port object.
        @param name The name of the connection. If None, a suitable default
                    will be created based on the names of the two ports.
        @param id The ID of this connection. If None, one will be generated by
               the RTC implementation.
        @param props Properties of the connection. Suitable defaults will be
                     set for required values if they are not already present.
        @raises WrongPortTypeError, MismatchedInterfacesError,
                MismatchedPolarityError

        '''
        # Corba ports can only connect to corba ports of the opposite polarity
        if not dest.porttype == 'CorbaPort':
            raise WrongPortTypeError
        # Check the interfaces and their respective polarities match
        if self.interfaces:
            if not dest.interfaces:
                raise MismatchedInterfacesError
            for intf in self.interfaces:
                match = dest.get_interface_by_instance_name(\
                            intf.instance_name)
                if not match:
                    raise MismatchedInterfacesError
                if intf.polarity == match.polarity:
                    # Polarity should be opposite
                    raise MismatchedPolarityError
        else:
            if dest.interfaces:
                raise MismatchedInterfacesError
        # Make the connection
        new_props = props.copy()
        if 'port.port_type' not in new_props:
            new_props['port.port_type'] = 'CorbaPort'
        super(CorbaPort, self).connect(dest, name, id, new_props)

    def get_interface_by_instance_name(self, name):
        '''Get an interface of this port by instance name.'''
        for intf in self.interfaces:
            if intf.instance_name == name:
                return intf
        return None

    @property
    def interfaces(self):
        '''The list of interfaces this port provides or uses.

        This list will be created at the first reference to this property.
        This means that the first reference may be delayed by CORBA calls,
        but others will return quickly (unless a delayed reparse has been
        triggered).

        '''
        if not self._interfaces:
            profile = self._obj.get_port_profile()
            self._interfaces = [SvcInterface(intf) \
                                for intf in profile.interfaces]
        return self._interfaces

    @property
    def properties(self):
        '''Properties of the port.'''
        return self._properties

    def _parse(self):
        # Parse the PortService object to build a port profile.
        profile = self._obj.get_port_profile()
        self._properties = nvlist_to_dict(profile.properties)
        Port._parse(self)


##############################################################################
## Service port interface object

class SvcInterface(object):
    '''Object representing the interface used by a service port.'''
    def __init__(self, intf_obj):
        '''Constructor.

        @param intf_obj The CORBA PortInterfaceProfile object to wrap.

        '''
        self._obj = intf_obj
        self._parse()

    def polarity_as_string(self, add_colour=True):
        '''Get the polarity of this interface as a string.

        @param add_colour If True, ANSI colour codes will be added to the
                          string.
        @return A string describing the polarity of this interface.

        '''
        if self.polarity == self.PROVIDED:
            result = 'Provided', ['reset']
        elif self.polarity == self.REQUIRED:
            result = 'Required', ['reset']
        if add_colour:
            return build_attr_string(result[1]) + result[0] + \
                build_attr_string('reset')
        else:
            return result[0]

    @property
    def instance_name(self):
        '''Instance name of the interface.'''
        return self._instance_name

    @property
    def polarity(self):
        '''Polarity of this interface.'''
        return self._polarity

    @property
    def polarity_string(self):
        '''The polarity of this interface as a coloured string.'''
        return self.polarity_as_string()

    @property
    def type_name(self):
        '''Type name of the interface.'''
        return self._type_name

    def _parse(self):
        # Parse the PortInterfaceProfile object.
        self._instance_name = self._obj.instance_name
        self._type_name = self._obj.type_name
        if self._obj.polarity == RTC.PROVIDED:
            self._polarity = self.PROVIDED
        else:
            self._polarity = self.REQUIRED

    ## Constant for provided interface polarity.
    PROVIDED = 1
    ## Constant for required interface polarity.
    REQUIRED = 2


##############################################################################
## Connection object

class Connection(object):
    '''An object representing a connection between two or more ports.'''
    def __init__(self, conn_profile_obj, owner=None):
        '''Constructor.

        @param conn_profile_obj The CORBA ConnectorProfile object to wrap.
        @param owner The owner of this connection. If the creator of this
                     object is not a Port object (or derivative thereof), this
                     value should be set to None.

        '''
        self._obj = conn_profile_obj
        self._owner = owner
        self._parse()

    def disconnect(self):
        '''Disconnect this connection.'''
        if not self.ports:
            raise NotConnectedError
        self.ports[0][1].object.disconnect(self.id)

    def has_port(self, port):
        '''Return True if this connection involves the given Port object.

        @param port The Port object to search for in this connection's ports.

        '''
        for p in self.ports:
            if port.object._is_equivalent(p[1].object):
                return True
        return False

    @property
    def id(self):
        '''The ID of the connection.'''
        return self._id

    @property
    def name(self):
        '''The name of the connection.'''
        return self._name

    @property
    def owner(self):
        '''This connection's owner, if created by a Port object.'''
        return self._owner

    @property
    def ports(self):
        '''The list of ports involved in this connection.

        The result is a list of tuples, (port name, port object). Each port
        name is a full path to the port (e.g. /localhost/Comp0.rtc:in) if
        this Connection object is owned by a Port, which is in turn owned by
        a Component in the tree. Otherwise, only the port's name will be used
        (in which case it will be the full port name, which will include the
        component name, e.g. 'ConsoleIn0.in'). The full path can be used to
        find ports in the tree.

        This list will be created at the first reference to this property.
        This means that the first reference may be delayed by CORBA calls,
        but others will return quickly (unless a delayed reparse has been
        triggered).

        '''
        def has_port(node, args):
            if node.get_port_by_ref(args):
                return node
            return None

        if not self._ports:
            self._ports = []
            for p in self._obj.ports:
                # My owner's owner is a component node in the tree
                if self.owner and self.owner.owner:
                    root = self.owner.owner.root
                    port_owner = [n for n in root.iterate(has_port,
                            args=p, filter=['is_component']) if n][0]
                    port_owner_path = port_owner.full_path
                    port_name = p.get_port_profile().name
                    prefix = port_owner.instance_name + '.'
                    if port_name.startswith(prefix):
                        port_name = port_name[len(prefix):]
                    self._ports.append((port_owner_path + ':' + \
                                            port_name,
                                        parse_port(p, self.owner.owner)))
                else:
                    self._ports.append((p.get_port_profile().name,
                                        parse_port(p, None)))
        return self._ports

    @property
    def properties(self):
        '''The connection's properties dictionary.'''
        return self._properties

    def _parse(self):
        # Parse the ConnectorProfile object.
        self._name = self._obj.name
        self._id = self._obj.connector_id
        self._ports = None
        self._properties = nvlist_to_dict(self._obj.properties)


# vim: tw=79

